<?php

/**
 * @author Luo Ning <luoning@luoning.me>
 * 正则表达式练习之IP
 * 
 * 身份证号码总共有4个部分（15位号码只有3部分），从左向右分别为：
 * 第一部分有6位，为居民在办理身份证时户口所在地的地址码；
 * 第二部分有8位（15位号码为6位），为居民出生日期码；第三部分有3位，为数字顺序码，也就是同一天出生的人的一个
 * 排序，奇数代表男性而偶数代表女性；
 * 第四部分也就是最后一部分有1位，为数字校验码，此部分只有18位号码才有；
 * 
 * 18位居民身份证号码最后一位——数字校验码的计算方法：
 * 1. 将身份证号码的前17位数分别乘以以下系数：7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2；
 * 2. 将以上分别相乘得到的结果相加；
 * 3. 将以上相加的结果除以11，得出余数；
 * 4. 以上得出的余数可能为0 - 10这11个数中的某一个数字。10是一个另类，因为我们的数字校验位只有1位显然需要一种替换
 * 方案，用1位将10换下，于是X派上用场了。注意了，数字校验位并不就是余数！！所得的11个余数：
 * 0，1，2，3，4，5，6，7，8，9，10 的数字校验位分别为：
 * 1，0，X，9，8，7，6，5，4，3，2
 *
 * 首先，地址码的前2位是省级的编号，到统计局去查询得知第1位非0，并且目前的范围为1-9，9是国外的身份证号码。第2位的
 * 范围为0-7。
 */


$pattern = '/^[1-9][0-7]\d{4}(19\d{2}|20\d{2})(0[1-9]|1[012])(0[1-9]|1[0-9]|2[0-9]|3[01])\d{3}([0-9]|X|x)/';

$string = '622630199308230339 232832983729712121 62263019930823033X';

if (preg_match_all($pattern, $string, $match)) {
	 echo 'The result is : '; 
	 var_dump($match); 
} else { 
	echo 'NO!'; 
} 